**********************************************************************
*  tutte - computes the Tutte Polynomial
*
*  Copyright (c) 2011-2014, Andrea Bedini <andrea.bedini@gmail.com>
*
*  Distributed under the terms of the Modified BSD License.
*  The full license is in the file COPYING, distributed as part of
*  this software.
**********************************************************************

This program computes the Tutte Polynomial of a user-supplied graph
using the algorithm described in:

  Bedini, A. & Jacobsen, J.L. A tree-decomposed transfer matrix for
  computing exact Potts model partition functions for arbitrary
  graphs, with applications to planar graph colourings. J. Phys. A:
  Math. Theor. 43, 385001 (2010).

** IF YOU USE THIS SOFTWARE FOR RESEARCH PLEASE CITE THE ABOVE PAPER **

* Requirements

  - A modern C++ compiler which supports C++11. I tested gcc 4.7 and clang 4.2.

  - gmplib, http://gmplib.org

  - Boost libraries, http://www.boost.org

    The required library (program_options) will be compiled
    automatically by the build system.

* Compilation and installation

  You need to set the environment variable BOOST_ROOT to the directory
  where the Boost libraries are located or supply the path on the
  command line.

  To compile the program you have to do

  $ git clone git://github.com/andreabedini/tutte.git
  $ cd tutte
  $ mkdir build
  $ cmake ..
  $ make

  Run some tests

  $ make test

  Optionally

  $ make install

* Input

  The input is expected to be passed to the program through the
  standard input. Additional messages are always printed on the error
  output. As in:

  $ cat my_graph | bin/tutte

  or

  $ bin/tutte < my_graph

  The result is presented on the standard output.

  The input format looks like this:

  0--1,1--2,2--3,3--0,4--5,5--6,6--7,7--4

  This describe a graph with 8 vertices and 8 edges. Each edge is
  represented as a pair of numbers each representing a vertex.

  It is *important* that the vertex numbering starts from zero, so
  that vertex indices are in [0..V) where V is the number of vertices.

  Alternatively an input file can be specified with the option --input-file

  $ bin/tutte --input-file my_input

  NOTE: The input graph has to be connected, giving as input a graph with
  multiple connected components will result in a runtime error.

* Options

  A list of options is available witht the command

  $ bin/tutte --help
  -h [ --help ]           Produce help message
  --input-file arg        Read the graph from a file.
  --degree                Use greedy degree algorithm [default].
  --fill-in               Use greedy fill-in algorithm.
  --local-degree          Use 'local' greedy degree algorithm.
  --local-fill-in         Use 'local' greedy fill-in algorithm.
  --elimination-order arg Specify a vertex elimination order.
  --print-tree            Print tree decomposition.
  --tree-only             Print tree decomposition and exit.
  -f [ --flow ]           Compute the flow polynomial
  -c [ --chromatic ]      Compute the chromatic polynomial
  --chinese-remainder     Use the chinese remainder trick.

  Options --flow and --chromatic tell the program to compute the
  relevant specialization of the Tutte polynomial. In the variables
  $(Q,v)$, passing --flow to the program sets $v = -Q$, while passing
  --chromatic sets $v = -1$.

  Options --degree and --fillin choose which algorithm has to be used
  to compute the tree decomposition. Greedy Degree and Greedy Fill-In
  algorithms are described in:

    Bodlaender, H.L. & Koster, A.M.C.A. Treewidth computations I. Upper
    bounds. Information and Computation 208, 259â€“275 (2010).

  'local' greedy degree algorithm and 'local' greedy fill-in algorithm
  are home-crafted modifications to the above algorithms to make them
  always output a path-decomposition.

  A vertex elimination order (in the terminology of Bodlaender and
  Koster) can be specified on directly on the command line as a comma
  separated list of vertices.

* Remarks

  Edges are assigned to bags as they appear in the elimination
  ordering. For the sake of generality and maintenance, problem
  specific optimizations, such as the pruning procedure described in
  the paper, are not implemented.
