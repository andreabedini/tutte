**********************************************************************
*  tutte - computes the Tutte Polynomial
*
*  Copyright (c) 2011-2014, Andrea Bedini <andrea.bedini@gmail.com>
*
*  Distributed under the terms of the Modified BSD License.
*  The full license is in the file COPYING, distributed as part of
*  this software.
**********************************************************************

This program computes the Tutte Polynomial of a user-supplied graph
using the algorithm described in:

  Bedini, A. & Jacobsen, J.L. A tree-decomposed transfer matrix for
  computing exact Potts model partition functions for arbitrary
  graphs, with applications to planar graph colourings. J. Phys. A:
  Math. Theor. 43, 385001 (2010).

** IF YOU USE THIS SOFTWARE FOR RESEARCH PLEASE CITE THE ABOVE PAPER **

* Requirements

  - A modern C++ compiler which supports C++11. I tested gcc 4.7 and clang 4.2.

  - gmplib, http://gmplib.org

  - Boost libraries, http://www.boost.org

    The required library (program_options) will be compiled
    automatically by the build system.

  - Boost.Build, distributed with the Boost libraries

    The rationale behind the choice of Boost.Build is in the binary
    incompatibilities between GNU libstdc++ in C++98 mode and in C++11
    mode and the new libc++ standard library than clang uses.
    Boost.Build assures everything is built with the same compilation
    flags, preventing linking issues.

* Compilation and installation

  You need to set the environment variable BOOST_ROOT to the directory
  where the Boost libraries are located or supply the path on the
  command line.

  To compile the program you have to do

  $ git clone git://github.com/andreabedini/tutte.git
  $ cd tutte

  Then, if you are using gcc

  $ b2 gcc release

  and if you are using clang

  $ b2 clang release

  The path to the boost libraries can also be specified on the command
  line:

  $ b2 -sBOOST_ROOT=$HOME/boost_1_53_0 gcc release

  A version suitable for debugging can be obtained by replacing
  'release' with 'debug' in the command line.

  On successful build, the executable 'tutte' will be placed in
  the subfolder 'bin'.

  A small set of tests in executed after each
  build but they can be run again invoking

  ./run_tests.sh bin/tutte

* Input

  The input is expected to be passed to the program through the
  standard input. Additional messages are always printed on the error
  output. As in:

  $ cat my_graph | bin/tutte

  or

  $ bin/tutte < my_graph

  The result is presented on the standard output.

  The input format looks like this:

  0--1,1--2,2--3,3--0,4--5,5--6,6--7,7--4

  This describe a graph with 8 vertices and 8 edges. Each edge is
  represented as a pair of numbers each representing a vertex.

  It is *important* that the vertex numbering starts from zero, so
  that vertex indices are in [0..V) where V is the number of vertices.

  Alternatively an input file can be specified with the option --input-file

  $ bin/tutte --input-file my_input

  NOTE: The input graph has to be connected, giving as input a graph with
  multiple connected components will result in a runtime error.

* Options

  A list of options is available witht the command

  $ bin/tutte --help
  -h [ --help ]           Produce help message
  --input-file arg        Read the graph from a file.
  --degree                Use greedy degree algorithm [default].
  --fill-in               Use greedy fill-in algorithm.
  --local-degree          Use 'local' greedy degree algorithm.
  --local-fill-in         Use 'local' greedy fill-in algorithm.
  --elimination-order arg Specify a vertex elimination order.
  --print-tree            Print tree decomposition.
  --tree-only             Print tree decomposition and exit.
  -f [ --flow ]           Compute the flow polynomial
  -c [ --chromatic ]      Compute the chromatic polynomial
  --chinese-remainder     Use the chinese remainder trick.

  Options --flow and --chromatic tell the program to compute the
  relevant specialization of the Tutte polynomial. In the variables
  $(Q,v)$, passing --flow to the program sets $v = -Q$, while passing
  --chromatic sets $v = -1$.

  Options --degree and --fillin choose which algorithm has to be used
  to compute the tree decomposition. Greedy Degree and Greedy Fill-In
  algorithms are described in:

    Bodlaender, H.L. & Koster, A.M.C.A. Treewidth computations I. Upper
    bounds. Information and Computation 208, 259â€“275 (2010).

  'local' greedy degree algorithm and 'local' greedy fill-in algorithm
  are home-crafted modifications to the above algorithms to make them
  always output a path-decomposition.

  A vertex elimination order (in the terminology of Bodlaender and
  Koster) can be specified on directly on the command line as a comma
  separated list of vertices.

* Remarks

  Edges are assigned to bags as they appear in the elimination
  ordering. For the sake of generality and maintenance, problem
  specific optimizations, such as the pruning procedure described in
  the paper, are not implemented.
